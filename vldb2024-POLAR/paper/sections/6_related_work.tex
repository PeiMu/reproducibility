\vspace{0.4cm}
\section{Related Work}
\label{related-work}
%
Besides the brief background in the introduction, here, we broadly survey related work and emphasize the differences of POLAR.

\textbf{Traditional AQP:} Adaptive query processing has received lots of attention in the data management literature, and great surveys \cite{BabuB05,DeshpandeIR07} and tutorials \cite{IvesDR07,DeshpandeHR06} already exist. Existing classifications distinguish AQP for traditional ad-hoc queries (or plan-based systems) versus continuous queries \cite{BabuB05}, as well as a spectrum of adaptivity from coarse- to fine-grained adaptation \cite{DeshpandeHR06}.
First, \emph{inter-query} optimization utilizes learned cardinalities for expressions \cite{BrunoC02,ChenR94,StillgerLMK01} for optimizing future queries. Second, \emph{inter-pipeline} optimization utilizes monitored statistics even within a single query. Examples are late binding (staged execution) with re-optimization at pipeline breakers \cite{DeshpandeHR06} or at parameter binding in parametric query optimization \cite{BizarroBD09}. Third, \emph{inter-operator} re-optimization compiles new remaining plans at so-called checkpoint operators \cite{KabraD98}. Similar, progressive and pro-active re-optimization apply plan changes if actual cardinalities are outside computed validity ranges \cite{MarklRSLP04,BabuBD05}. Fourth, \emph{intra-operator} adaptivity allows changing plans after partial operator evaluation. Examples are union stitch-up plans and handling of state in double-pipelined hash joins \cite{IvesHW04}, intra-query adaptivity via reinforcement learning in SkinnerDB \cite{TrummerWMMJA19,TrummerWWMMJAR21,WeiT22}, as well as adaptive join reordering of index-nested-loop joins with depleted states for correctness \cite{LiSMBCL07}. Fifth, there is tuple routing with routing policies in Eddies~\cite{HellersteinA00,Arpaci-Dusseau03,Deshpande04,BizarroBDW05}. Many of these strategies require both optimizer and runtime extensions for effective and efficient adaptivity. Moreover, Eddies requires complex tuple tracking to produce correct results. Instead, POLAR aims at a simple system integration with bounded exploration overhead.

\textbf{AQP for Continuous Queries:} The adaptation of continuous queries---on infinite data streams---always focuses on \emph{intra-operator} and \emph{tuple-routing}. Early stream processing systems with adaptive query processing include STREAM \cite{BabuW04}, Aurora \cite{AbadiCCCCLSTZ03}/Borealis~\cite{AbadiABCCHLMRRTXZ05}, NiagaraCQ \cite{ChenJDTW00}, and TelegraphCQ \cite{ChandrasekaranDFHHKMRRS03}. Unique characteristics are the incremental collection of statistics to detect workload changes \cite{BabuMMNW04}, multi-query optimization with queries entering and leaving the system, asynchronous optimization outside the critical path \cite{Boehm2011}, the applicability of load shedding \cite{TatbulCZCS03}, as well as stateful operators and queues which require draining for plan changes \cite{WangFMWZ19}. Modern distributed stream processing engines like Flink \cite{AlexandrovBEFHHKLLMNPRSSHTW14}, Spark \cite{ZahariaDLHSS13}, Beam \cite{AkidauBCCFLMMPS15}, Heron~\cite{KulkarniBFKKMPR15}/Dhalion~\cite{FloratouAGRR17}, and NebulaStream \cite{ZeuchCMGGGBTM20} further deal with the reconfiguration of distributed query topologies. In contrast to POLAR, AQP is naturally deeply integrated in almost all components of such stream processing engines.

\textbf{Different Plans for Different Data:} Both, ad-hoc and continuous queries are typically compiled and optimized according to average statistics. However, especially in correlated data, relations are naturally divided into partitions with different characteristics \cite{TzoumasDJ10}. Early work on selectivity-based partitioning \cite{Polyzotis05} and content-based routing \cite{BizarroBDW05} address this observation by generating different plans for different partitions, and different value-based routing policies. Such approaches often leverage more fine-grained statistics such as serial histograms (i.e., detailed frequency matrices) \cite{Ioannidis93}. Recent work on multi-way join size estimation \cite{MullerM22,IzenovDRS21} utilize hash-based translation grids \cite{MullerM22} and AKMV sketches \cite{BeyerHRSG07} as well as fast-AGMS sketches \cite{IzenovDRS21}. Since selectivity-based partitioning might compute the same intermediate multiple times, further work on sharing-aware horizontal partitioning \cite{TzoumasDJ10} introduced a conditional join plan, and related optimization and runtime techniques. Exploratory AQP via reinforcement learning like SkinnerDB~\cite{TrummerWMMJA19} would also lend itself to discovering different paths. Due to repeated path sampling, POLAR can also exploit different paths for different data, but only if these tuples are scanned in a clustered manner.

\textbf{Micro Adaptivity:} Besides finding alternative plans (e.g., join orders), some work also focused on micro adaptivity. Raducanu et al. introduced this concept in Vectorwise \cite{RaducanuBZ13} by providing alternative kernel implementations (e.g., branch, no-branch), measuring their runtime on sample vectors, and selecting the best configuration via a learning algorithm. Later work used performance counters to minimize the measurement overhead, and more properties such as sortedness and co-clustering \cite{ZeuchPF16}. Other forms of micro adaptivity are compiling continuous queries for HW specialization, parallelization, as well as exploitation of selectivities or value distributions \cite{GrulichBZTBCRM20,RosenfeldBM23}. Micro adaptivity requires specific optimization algorithms, whereas POLAR relies on existing optimizers without changes. 

\textbf{AQP for Non-relational Workloads:} AQP ideas have also been applied and extended for non-relational systems and workloads. Examples include JIT compilation for programming languages~\cite{HolzleU94} (e.g., Java or WebAssembly); lazy expression compilation in TensorFlow~\cite{MoldovanDWJLNSR19}, dynamic recompilation of blocks and functions in SystemML~\cite{BoehmBERRSTT14}; periodic or on-demand reoptimization of integration flows \cite{Boehm2011}; and AQP on raw data \cite{KarpathiotakisBAA14}. These systems also incrementally collect telemetry and perform plan adaptation, but unlike POLAR, seek a single optimal plan or configuration. 

\textbf{Learned Optimizers and Estimators:} With the trend towards ML for systems \cite{KraskaBCDP18}, there has been substantial progress on improved cardinality estimates that could mitigate some of the need for AQP. Early work focused on the featurization of schemas and workloads and sampling-based training data collection \cite{KipfKRLBK19,DuttWNKNC19,YangLKWDCAHKS19}. Hilprecht and Binnig later introduced representations for zero-shot cost models \cite{HilprechtB22,HilprechtB22b} that can generalize to unseen database instances. Early work like LEO \cite{StillgerLMK01} also focused on learned cardinalities, but in retrospective had the problem of \enquote{fleeing from knowledge to ignorance} \cite{Lohman17} because the exponential search space gets only sparsely sampled,  and skewed cardinalities are often larger than the estimates under independence assumption. However, recent work has shown that learned optimizers and cardinality estimators can learn from mistakes \cite{MarcusNMZAKPT19,MarcusNMTAK21}, making a case for stateful, learning-based systems \cite{abs-2303-15308}, especially for cloud DBMS like Snowflake \cite{DagevilleCZAABC16} or Redshift \cite{GuptaATKPSS15}. In contrast to POLAR, integrating learned optimizers and estimators is still very invasive in terms of system complexity, bootstrapping, and integration points.
